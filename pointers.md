# Ссылки и указатели

## Ссылки

Ссылка представляет способ манипулировать каким-либо объектом. Фактически ссылка - это альтернативное имя для объекта. Для определения ссылки применяется знак амперсанда &:

```c++
int number = 5;
int &refNumber = number;
```

В данном случае определена ссылка refNumber, которая ссылается на объект number. При этом в определении ссылки используется тот же тип, который представляет объект, на который ссылка ссылается, то есть в данном случае int.

При этом нельзя просто определить ссылку:

```c++
int &refNumber;
```

Она обязательно должна указывать на какой-нибудь объект.

После установления ссылки мы можем через нее манипулировать самим объектом, на который она ссылается:

```c++
#include <iostream>
 
int main()
{
    int number = 5;
    int &refNumber = number;
    std::cout << refNumber << std::endl; // 5
    refNumber = 20;
    std::cout << number << std::endl;   // 20
         
    return 0;
}
```

Изменения по ссылке неизбежно скажутся и на том объекте, на который ссылается ссылка.

Можно определять не только ссылки на переменные, но и ссылки на константы. Но при этом ссылка сама должна быть константной:

```c++
const int number = 5;
const int &refNumber = number;
std::cout << refNumber << std::endl; // 5
//refNumber = 20;       изменять значение по ссылке нельзя
```

Также константная ссылка может указывать и на обычную переменную, только значение по такой ссылке мы не сможем изменить:

```c++
int number = 5;
const int &refNumber = number;
std::cout << refNumber << std::endl; // 5
 
//refNumber = 20;       изменять значение по ссылке на константу нельзя
     
// но мы можем изменить саму переменную
number = 20;
std::cout << refNumber << std::endl;    // 20
```

В данном случае несмотря на то, что мы не можем напрямую изменить значение по константной ссылке, тем не менее мы можем изменить сам объект, что приведет естественно к изменению константной ссылки.

## Указатели

Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту. Однако в отличие от ссылок указатели обладают большими возможностями.

Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *. Например, определим указатель на объект типа int:

```c++
int *p;
```

Пока указатель не ссылается ни на какой объект. При этом в отличие от ссылки указатель необязательно инициализировать каким-либо значением. Теперь присвоим указателю адрес переменной:

```c++
int x = 10;     // определяем переменную
int *p;         // определяем указатель
p = &x;         // указатель получает адрес переменной
```
Для получения адреса переменной применяется операция  &. Что важно, переменная x имеет тип int, и указатель, который указывает на ее адрес, тоже имеет тип int. То есть должно быть соответствие по типу.

Если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатиричное значение:

```c++
#include <iostream>
 
int main()
{
    int x = 10;     // определяем переменную
    int *p;         // определяем указатель
    p = &x;         // указатель получает адрес переменной
    std::cout << "p = " << p << std::endl;
    return 0;
}
```
Консольный вывод программы:
>p = 0x60fe98

В каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0x60fe98. То есть в памяти компьютера есть адрес 0x60fe98, по которому располагается переменная x.

#### Разыменование указателей

Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной x. Для этого применяется операция  *  или операция разыменования, то есть та операция, которая применяется при определении указателя. Результатом этой операции всегда является объект, на который указывает указатель. Применим данную операцию и получим значение переменной x:

```c++
#include <iostream>
 
int main()
{
    int x = 10;
    int *p;
    p = &x;
    std::cout << "Address = " << p << std::endl;
    std::cout << "Value = " << *p << std::endl;
    return 0;
}
```

Консольный вывод:
>Address = 0x60fe98
>Value = 10

Значение, которое получено в результате операции разыменования, можно присвоить другой переменной. Также используя указатель, мы можем менять значение по адресу, который хранится в указателе:

```c++
int x = 10;
int *p  = &x;

int y = *p;
std::cout << "Value = " << y << std::endl;    // 10

*p = 45;
std::cout << "x = " << x << std::endl;     // 45
```

Так как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится.

#### Операции сравнения

Так как память компьютера в программе схематично можно представить как массив байтов, то к указателям могут применяться операции сравнения >, >=, <, <=,==, !=. Операции сравнения применяются только к указателям одного типа и к значениям NULL и nullptr. 

#### Арифметика указателей

Указатели могут участвовать в арифметических операциях (сложение, вычитание, инкремент, декремент). Однако сами операции производятся немного иначе, чем с числами. И многое здесь зависит от типа указателя.

К указателю можно прибавлять целое число, и также можно вычитать из указателя целое число. Кроме того, можно вычитать из одного указателя другой указатель.

Операция инкремента ++ увеличивает значение на единицу. В случае с указателем увеличение на единицу будет означать увеличение адреса, который хранится в указателе, на размер типа указателя. То есть в данном случае указатель на тип int, а размер объектов int в большинстве архитектур равен 4 байтам. Поэтому увеличение указателя типа int на единицу означает увеличение значение указателя на 4.

Фактически увеличение на единицу означает, что мы хотим перейти к следующему объекту в памяти, который находится за текущим и на который указывает указатель. А уменьшение на единицу означает переход назад к предыдущему объекту в памяти.

### Указатели и массивы

В C++ указатели и массивы тесно связаны. Обычно компилятор преобразует массив в указатели. С помощью указателей можно манипулировать элементами массива, как и с помощью индексов.

Имя массива по сути является адресом его первого элемента. Соответственно через операцию разыменования мы можем получить значение по этому адресу:

```c++
int a[] = {1, 2, 3, 4, 5};
std::cout << "a[0] = " << *a << std::endl;    // a[0] = 1
```

Прибавляя к адресу первого элемента некоторое число, мы можем получить определенны элемент массив. Например, в цикле пробежимся по всем элементам:

```c++
#include <iostream>
 
int main()
{
    int a[5] = {1, 2, 3, 4, 5};
     
    for (int i = 0; i < n; i++)
    {
        std::cout << "a[" << i << "]: address=" << a + i << " value=" << *(a + i) << std::endl;
    }
     
    return 0;
}
```

По сути - имя массива <=> указатель на первый элемент массива. Следовательно операции `a[i]` и `*(a + i)` -- равносильны

#### Указатели на функции

Указатель на функцию (function pointer) хранит адрес функции. По сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции.

Самым распространенным указателем на функцию является ее имя. С помощью имени функции можно вызывать ее и получать результат ее работы.

Но также указатель на функцию мы можем определять в виде отдельной переменной с помощью следующего синтаксиса:

```c++
тип (*имя_указателя) (параметры);
```

Здесь **`тип`** представляет тип возвращаемого функцией значения.

**`имя_указателя`**  представляет произвольно выбранный идентификатор в соответствии с правилами о наименовании переменных.

И  **`параметры`**  определяют тип и название параметров через запятую при их наличии.

Например, определим указатель на функцию:

```c+++
void (*message) ();
```

В данном случае определен указатель, который имеет имя  message. Он может указывать на функции без параметров, которые ничего не возвращают.

Используем указатель на функцию:

```c++
#include <iostream>
 
void hello()
{
    std::cout << "Hello, World" << std::endl;
}

void goodbye()
{
    std::cout << "Good Bye, World" << std::endl;
}
  
int main()
{
    void (*message)();
      
    message=hello;
    message();
    message = goodbye;
    message();
      
    return 0;
}
```

При определении указателя стоит обратить внимание на скобки вокруг имени. Так, использованное выше определение

```c++
void (*message) ();
```

НЕ будет аналогично следующему определению:

```c++
void *message ();
```

Во втором случае определен не указатель на функцию, а прототип функции message, которая возвращает указатель типа `void*`.

## Динамические объекты

В C++ можно использовать различные типы объектов, которые различаются по использованию памяти. Так, глобальные объекты создаются при запуске программы и освобождаются при ее завершении. Локальные автоматические объекты создаются в блоке кода и удаляются, когда этот блок кода завершает работу. Локальные статические объекты создаются перед их первым использованием и освобождаются при завершении программы.

Глобальные, а также статические локальные объекты помещаются в статической памяти, а локальные автоматические объекты размещаются в стеке. Объекты в статической памяти и стеке создаются и удаляются компилятором. Статическая память очищается при завершении программы, а объекты из стека существуют, пока выполняется блок, в котором они определены.

В дополнение к этим типам в C++ можно создавать  **`динамические объекты`**. Продолжительность их жизни не зависит от того, где они созданы. Динамические объекты существуют, пока не будут удалены явным образом. Динамические объекты размещаются в  динамической памяти  (free store).

Для управления динамическими объектами применяются операторы  **`new`** и  **`delete`**.

Оператор  **`new`**  выделяет место в динамической памяти для объекта и возвращает указатель на этот объект.

Оператор  **`delete`**  получает указатель на динамический объект и удаляет его из памяти.

### Выделение памяти
Оператор new создает новый объект типа int в динамической памяти и возвращает указатель на него. Значение такого объекта неопределено.
```c++
int *ptr = new int;
```
Также можно инициализировать объект при создании:

```c++
int *p1 = new int();    // значение по умолчанию - 0
std::cout << "p1: " << *p1 << std::endl;  // 0
 
int *p2 = new int(12);
std::cout << "p2: " << *p2 << std::endl;   // 12
```

При таком использовании оператора **`new`**  он создает объект в динамической памяти, после чего вызывает его конструктор с указанными аргументами. 

```c++
#include <iostream>

class point {
public:
    int x, y;

    point(int X, int Y) {
        x = X;
        y = Y;
    }
};

int main() {

	int *p = new point(10, 10);	
	std::cout << (*p).x << ' ' << (*p).y << std::endl;	// 10 10 

	return 0;
}
```

### Освобождение памяти

Динамические объекты будут существовать пока не будут явным образом удалены. И после завершения использования динамических объектов следует освободить их память с помощью оператора  delete:

```c++
int *p1 = new int(12);
std::cout << "p1: " << *p1 << std::endl;  // 0
delete p1;
```

### Динамические массивы

Кроме отдельных динамических объектов в языке C++ мы можем использовать динамические массивы. Для выделения памяти под динамический массив также используется оператор new, после которого в квадратных скобках указывается, сколько массив будет содержать объектов:

```c++
int *numbers = new int[n];
```

Причем в этом случае оператор new также возвращает указатель на объект типа int - первый элемент в созданном массиве.

Для удаления динамического массива и освобождения его памяти применяется специальная форма оператора  delete:

```c++
delete[] numbers;
```
