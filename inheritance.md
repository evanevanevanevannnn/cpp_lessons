##  Конструкторы и деструкторы

### Конструкторы

На прошлом занятии нами был написал следующий класс:
```c++
class Person
{
public:
    std::string name;
    int age;
};
```
И мы можем установить значения для переменных класса Person, можем получить их значения во внешние переменные. Однако если мы попробуем получить значения переменных name и age до их установки, то результаты будут неопределенными:

```c++
Person person;
std::cout << "Name: " << person.name << "\tAge: " << person.age << endl;
```

Чтобы избежать подобной ситуации применяются специальные функции инициализации или конструкторы. Они позволяют инициализировать объект класса. Так, изменим код программы следующим образом:

```c++
#include <iostream>
#include <string>
 
class Person
{
public:
    std::string name;
    int age;
    
    Person(std::string _name, int _age) 
    {
        name = _name;
        age = _age;
    }
};
```

Теперь в классе Person определен конструктор:

```c++
Person(std::string _name, int _age) 
{
    name = _name;
    age = _age;
}
```
Следовательно мы можем написать:

```c++
Person person = Person("Tom", 22);
std::cout << "Name: " << person.name << "\tAge: " << person.age << endl;
```

По сути конструктор представляет функцию, которая может принимать параметры и которая должна называться по имени класса. В данном случае конструктор принимает два параметра и передает их значения полям name и age.

После этого вызова у объекта person для поля name будет определено значение "Tom", а для поля age - значение 22. Впоследствии мы также сможем обращаться к этим полям и переустанавливать их значения.

Тажке можно использовать сокращенную форму инициализации:

```c++
Person person("Tom", 22);
```

По сути она будет эквивалентна предыдущей.

Подобным образом мы можем определить несколько конструкторов и затем их использовать:

```c++
#include <iostream>
#include <string>

class Person
{
public:
    std::string name;
    int age;
    
    Person() {
        name = "Tom";
        age = 18;
    }

    Person(std::string _name, int _age) 
    {
        name = _name; 
        age = _age;
    }
};
```

Так же существует другая сокращенная форма инициализации переменных:

```c++
Person(std::string _name, int _age): name(_name), age(_age) {}
```

По сути для каждого указанного после двоеточия объекта вызывается его конструктор от указанных в скобках аргументов. После двоеточия в том числе можно вызывать и конструктор данного класса:

```c++
#include <iostream>
#include <string>

class Person
{
public:
    std::string name;
    int age;
    
    Person(): Person("Tom", 18) {}

    Person(std::string _name, int _age) 
    {
        name = _name; 
        age = _age;
    }
};
```

### Деструкторы

Деструктор выполняет освобождение использованных объектом ресурсов и удаление нестатических переменных объекта. По сути деструктор - это функция, которая называется по имени класса (как и конструктор) и перед которой стоит тильда (~). Деструктор не имеет возвращаемого значения и не принимает параметров. Каждый класс может иметь только один деструктор.

Деструктор автоматически вызывается, когда удаляется объект. Удаление объекта происходит в следующих случаях:

-   когда завершается выполнение области видимости, внутри которой определены объекты
-   когда удаляется контейнер (например, массив), который содержит объекты
-   когда удаляется объект, в котором определены переменные, представляющие другие объекты
- динамически созданные объекты удаляются при применении к указателю на объект оператора  delete

Рассмотрим следующую ситуацию:

```c++
#include <iostream>
#include <string>
 
class Person
{
public: 
    std::string name;
    
    Person(std::string n)
    {
        name = n;
    }
    
    ~Person()
    {
        std::cout << "Destructor called for Person " << name << std::endl;
    }
};

int main()
{
    Person tom("Tom");
    std::cout << "End of Main" << std::endl;
    return 0;
} // вызывается деструктор для объекта tom
```
В классе Person определен деструктор:
```c++
~Person()
{
    std::cout << "Destructor called for Person " << name << std::endl;
}
```

Все, что делает данный деструктор, это выводит на консоль соответствующее сообщение. Как правило, деструкторы определяют код для освобождения ресурсов, но в данном случае нам не надо освобождать никаких ресурсов, и мы могли бы определить даже пустой деструктор.

При этом выполнение самого деструктора еще не удаляет сам объект. Непосредственно удаление объекта производится в ходе явной фазы удаления, которая следует после выполнения деструктора.

Стоит также отметить, что для любого класса, который не определяет собственный деструктор, компилятор сам создает деструктор. Например, если бы класс Person не имел бы явно определенного деструктора, то для него автоматически создавался бы следующий деструктор:

```c++
~Person(){}
```

## Наследование 
**Наследование** представляет один из ключевых аспектов объектно-ориентированного программирования, который позволяет наследовать функциональность одного класса или базового класса в другом - производном классе.

Зачем нужно наследование? Рассмотрим небольшую ситуацию, допустим, у нас есть классы, которые представляют классы круга и квадрата:
```c++
class Shape {
public:
    double x, y;

    void printCoordinates() {
        std::cout << x << ' ' << y;
    }
};

class Circle {
public:
    double x, y;
    double r;

    void printCoordinates() {
        std::cout << x << ' ' << y;
    }
};
```

В данном случае класс Circle фактически содержит функционал класса Shape: свойства x, y и функцию printCoordinates. И было бы не совсем правильно повторять функциональность одного класса в другом классе, тем более что по сути любой круг в любом случае является фигурой. Поэтому в этом случае лучше использовать так называемый механизм наследования. Унаследуем класс Circle от класса Shape:

```c++
class Shape {
public:
    double x, y;

    void printCoordinates() {
        std::cout << x << ' ' << y;
    }
};

class Circle : public Shape {
public:
    double r;
};
```

Чтобы унаследовать один класс от другого после названия класса ставится двоеточие, затем идет название класса, от которого мы хотим унаследовать функциональность. В этом отношении класс Shape еще будет называться базовым классом, а Circle - производным классом.

Перед названием базового класса также можно указать спецификатор доступа, как в данном случае используется спецификатор  public, который позволяет использовать в производном классе все открытые члены базового класса. Другие спецификаторы доступа мы осудим позже.

После установки наследования мы можем убрать из класса Circle те переменные, которые уже определены в классе Shape. Используем оба класса:

```c++
#include <iostream>

class Shape {
public:
    double x, y;

    void printCoordinates() {
        std::cout << x << ' ' << y;
    }
}

class Circle : public Shape {
public:
    double r;
}

int main() {

    Shape shape;
    shape.x = 0;
    shape.y = 0;
    shape.printCoordinates();

    Circle circle;
    circle.x = 10;
    circle.y = 10;
    circle.r = 10;
    circle.printCoordinates(); 

    return 0;
}
```

Таким образом, через переменную класса Circle мы можем обращаться ко всем открытым членам класса Shape.

