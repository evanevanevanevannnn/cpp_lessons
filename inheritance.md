##  Конструкторы и деструкторы

### Конструкторы

На прошлом занятии нами был написал следующий класс:
```c++
class Person
{
public:
    string name;
    int age;
};
```
И мы можем установить значения для переменных класса Person, можем получить их значения во внешние переменные. Однако если мы попробуем получить значения переменных name и age до их установки, то результаты будут неопределенными:

```c++
Person person;
cout << "Name: " << person.name << "\tAge: " << person.age << endl;
```

Чтобы избежать подобной ситуации применяются специальные функции инициализации или конструкторы. Они позволяют инициализировать объект класса. Так, изменим код программы следующим образом:

```c++
#include <iostream>
#include <string>
using std::string;
using std::cout;
using std::endl;
 
class Person
{
public:
    string name;
    int age;
    Person(string n, int a) 
    {
        name = n; age = a;
    }
};
int main()
{
    Person person = Person("Tom", 22);
    cout << "Name: " << person.name << "\tAge: " << person.age << endl;
    person.name = "Bob";
     
    return 0;
}
```

Теперь в классе Person определен конструктор:

```c++
Person(string n, int a) 
{
    name = n; age = a;
}
```

По сути конструктор представляет функцию, которая может принимать параметры и которая должна называться по имени класса. В данном случае конструктор принимает два параметра и передает их значения полям name и age.

Если в классе определены конструкторы, то при создании объекта этого класса необходимо вызвать один из его конструкторов.

Вызов конструктора получает значения для параметров и возвращает объект класса:

```c++
Person person = Person("Tom", 22);
```

После этого вызова у объекта person для поля name будет определено значение "Tom", а для поля age - значение 22. Впоследствии мы также сможем обращаться к этим полям и переустанавливать их значения.

Тажке можно использовать сокращенную форму инициализации:

```c++
Person person("Tom", 22);
```

По сути она будет эквивалентна предыдущей.

Подобным образом мы можем определить несколько конструкторов и затем их использовать:

```c++
#include <iostream>
#include <string>
using std::string;
using std::cout;
using std::endl;
 
class Person
{
public:
    string name;
    int age;
    Person(string n, int a) 
    {
        name = n; 
        age = a;
    }
    Person(string n)
    {
        name = n; 
        age = 18;
    }
    Person()
    {
        name = "Bob"; 
        age = 18;
    }
};
int main()
{
    Person tom("Tom", 22);
    cout << "Name: " << tom.name << "\tAge: " << tom.age << endl;
    Person sam("Sam");
    cout << "Name: " << sam.name << "\tAge: " << sam.age << endl;
    Person bob = Person();
    cout << "Name: " << bob.name << "\tAge: " << bob.age << endl;
    return 0;
}
```

### Деструкторы

Деструктор выполняет освобождение использованных объектом ресурсов и удаление нестатических переменных объекта. По сути деструктор - это функция, которая называется по имени класса (как и конструктор) и перед которой стоит тильда (~). Деструктор не имеет возвращаемого значения и не принимает параметров. Каждый класс может иметь только один деструктор.

Деструктор автоматически вызывается, когда удаляется объект. Удаление объекта происходит в следующих случаях:

-   когда завершается выполнение области видимости, внутри которой определены объекты
-   когда удаляется контейнер (например, массив), который содержит объекты
-   когда удаляется объект, в котором определены переменные, представляющие другие объекты
- динамически созданные объекты удаляются при применении к указателю на объект оператора  delete

Рассмотрим следующую ситуацию:

```c++
#include <iostream>
#include <string>
 
class Person
{
public: 
    Person(std::string n)
    {
        name = n;
    }
    ~Person()
    {
        std::cout << "Destructor called for Person " << name << std::endl;
    }
private:
    std::string name;
};
int main()
{
    Person tom("Tom");
    Person *sam = new Person("Sam");
    delete sam;     // вызывается деструктор для объекта sam
    
    std::cout << "End of Main" << std::endl;
    return 0;
} // вызывается деструктор для объекта tom
```
В классе Person определен деструктор:
```c++
~Person()
{
    std::cout << "Destructor called for Person " << name << std::endl;
}
```

Все, что делает данный деструктор, это выводит на консоль соответствующее сообщение. Как правило, деструкторы определяют код для особождения ресурсов, но в данном случае нам не надо освобождать никаких ресурсов, и мы могли бы определить даже пустой деструктор.

В функции main создается переменная tom, которая хранит объект Person. Это обычная переменная, не указатель. И для нее деструктор будет вызываться, когда завершит выполнение та область видимости, где эта переменная определена, то есть функция main.

Также здесь определен указатель bob, который указывает на объект Person. Это динамический объект, который определяется с помощью ключевого слова new. Когда такие объекты выходят из области видимости, то для них автоматически не выполняется деструктор. Поэтому для вызова деструктора и удаления таких объектов применяется оператор  delete:

```c++
Person *sam = new Person("Sam");
delete sam;     // вызывается деструктор для объекта sam
```

При этом выполнение самого деструктора еще не удаляет сам объект. Непосредственно удаление объекта производится в ходе явной фазы удаления, которая следует после выполнения деструктора.

Стоит также отметить, что для любого класса, который не определяет собственный деструктор, компилятор сам создает деструктор. Например, если бы класс Person не имел бы явно определенного деструктора, то для него автоматически создавался бы следующий деструктор:

```c++
~Person(){}
```

## Наследование 
**Наследование** представляет один из ключевых аспектов объектно-ориентированного программирования, который позволяет наследовать функциональность одного класса или базового класса (base class) в другом - производном классе (derived class).

Зачем нужно наследование? Рассмотрим небольшую ситуацию, допустим, у нас есть классы, которые представляют человека и работника предприятия:
```c++
class Person
{
public:
    std::string name;       //  имя
    int age;                // возраст
    void display()
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
};
class Employee
{
public:
    std::string name;       // имя
    int age;                // возраст
    std::string company;    // компания
    void display()
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
};
```

В данном случае класс Employee фактически содержит функционал класса Person: свойства name и age и функцию display. И было бы не совсем правильно повторять функциональность одного класса в другом классе, тем более что по сути сотрудник предприятия в любом случае является человеком. Поэтому в этом случае лучше использовать механизм наследования. Унаследуем класс Employee от класса Person:

```c++
class Person
{
public:
    std::string name;       //  имя
    int age;                // возраст
    void display()
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
};
class Employee : public Person
{
public:
    std::string company;    // компания
};
```

Для установки отношения наследования после название класса ставится двоеточие, затем идет название класса, от которого мы хотим унаследовать функциональность. В этом отношении класс Person еще будет называться базовым классом, а Employee - производным классом.

Перед названием базового класса также можно указать спецификатор доступа, как в данном случае используется спецификатор  public, который позволяет использовать в производном классе все открытые члены базового класса. Если мы не используем модификатор доступа, то класс Employee ничего не будет знать о переменных name и age и функции display.

После установки наследования мы можем убрать из класса Employee те переменные, которые уже определены в классе Person. Используем оба класса:

```c++
#include <iostream>
#include <string>
 
class Person
{
public:
    std::string name;       //  имя
    int age;                // возраст
    void display()
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
};
class Employee : public Person
{
public:
    std::string company;    // компания
};
 
int main()
{
    Person tom;
    tom.name = "Tom";
    tom.age = 23;
    tom.display();
 
    Employee bob;
    bob.name = "Bob";
    bob.age = 31;
    bob.company = "Microsoft";
    bob.display();
 
    return 0;
}
```

Таким образом, через переменную класса Employee мы можем обращаться ко всем открытым членам класса Person.

