### Определение классов
Кроме использования встроенных типов, таких как int, double и т.д., мы можем определять свои собственные типы или классы. Класс представляет составной тип, который может использовать другие типы.

Класс предназначен для описания некоторого типа объектов. То есть по сути класс является планом объекта. А объект представляет конкретное воплощение класса, его реализацию.

Класс может определять переменные и константы для хранения состояния объекта и функции для определения поведения объекта.

Например, определим простейший класс:

__Пример__
```c++
class Person 
{

};
```

Для определения класса применяется ключевое слово  class, после которого идет собственно название класса. В данном случае класс называется Person и представляет человека. После названия класса идет блок кода, который определяет тело класса.

После определения класса мы можем создавать его переменные:

```c++
class Person
{

};

int main()
{
Person person;
return 0;
}
```

Но данный класс пока что ничего не делает, поэтому изменим его:

```c++
class Person 
{
public:
	std::string name;
	int age;

	void printInfo()
	{
		std::cout << "My name and age are: " << name << ", " << age << "\n";
	}
}
```
Теперь класс Person имеет две переменных name и age, которые предназначены для хранения имени и возраста человека соответственно, а так же функцию(метод) класса, который выводит информацию на экран.

Затем в функции main создается один объект класса Person. Через точку мы можем обратиться к его переменным и методам.
```c++
int main()
{
	Person person;
	person.name = "Tom";
	person.age = 10;

	person.printInfo();
	
	return 0;
}
```

### Конструкторы

В прошлой теме был разработан класс Person. И мы можем установить значения для переменных класса Person, можем получить их значения во внешние переменные. Однако если мы попробуем получить значения переменных name и age до их установки, то результаты будут неопределенными:

```c++
Person person;
cout << "Name: " << person.name << "\tAge: " << person.age << "\n";
```

Чтобы избежать подобной ситуации применяются специальные функции инициализации или конструкторы. Они позволяют инициализировать объект класса. Так, изменим код программы следующим образом:

```c++
class Person
{
public:
    std::string name;
    int age;
    
    Person(const std::string &n, int a) 
    {
        name = n; age = a;
    }
    
    void printInfo()
	{
		std::cout << "My name and age are: " << name << ", " << age << "\n";
	}
};
```

Теперь в классе Person определен конструктор:
```c++
Person(const std::string &n, int a) 
{
    name = n; age = a;
}
```

Теперь мы можем указывать аргументы при создании объектов класса Person:
```c++
int main()
{
    Person tom("Tom", 22);
    cout << "Name: " << tom.name << "\tAge: " << tom.age << endl;
    Person sam("Sam");
    cout << "Name: " << sam.name << "\tAge: " << sam.age << endl;
    Person bob = Person();
    cout << "Name: " << bob.name << "\tAge: " << bob.age << endl;
    return 0;
}
```

###  Управление доступом. Инкапсуляция

Выше мы описали класс Person:

```c++
class Person
{
public:
    std::string name;
    int age;
    
    Person(const std::string &n, int a) 
    {
        name = n; age = a;
    }
    
    void printInfo()
	{
		std::cout << "My name and age are: " << name << ", " << age << "\n";
	}
};
```
Спецификатор  public  является спецификатором доступа (access specifier), то есть определяет параметры доступа к членам класса - переменным и функциям. В частности, он делает их доступными из любой части программы или открытыми. По сути спецификатор public определяет общедоступный интерфейс класса.

То есть в данном случае поля name и age являются открытыми, и мы можем присвоить им во внешнем коде любые значения:

```c++
Person tom("Tom", 22);
tom.name = "abyrvalk";
tom.age = -1001;
```
 В том числе можно присвоить какие-то недопустимые значения, например, отрицательное значение для возраста пользователя. Естественно это не очень хорошая ситуация.

Однако с помощью другого спецификатора  private  мы можем скрыть реализацию членов класса, то есть сделать их закрытыми, инкапсулировать внутри класса.

Перепишем класс Person с исключением спецификатора private:

```c++
class Person
{
public:
    Person(string n, int a)
    {
        name = n; age = a;
    }
    
    void printInfo()
	{
		std::cout << "My name and age are: " << name << ", " << age << "\n";
	}
    
    void setAge(int a) 
    {
        if (a > 0 && a < 100)
	        age = a;
    }
    
    std::string getName()
    {
        return name;
    }
    
    int getAge()
    {
        return age;
    }
    
private:
    std::string name;
    int age;
     
};
 
int main()
{
    Person tom("Tom", 22);
    // string personName = tom.name;    // ошибка - переменная name закрытая
    cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << endl;
    tom.setAge(31);
    cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << endl;
    tom.setAge(291);
    cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << endl;
    return 0;
}
```

Теперь переменные name и age в классе Person являются закрытыми, поэтому мы не можем обратиться к ним напрямую. Мы можем к ним обращаться только внутри класса.

Чтобы все таки можно было получить извне значения переменных name и age, определены дополнительные функции getAge и getName. Установить значение переменной name напрямую можно только через конструктор, а значение переменной age - через конструктор или через функцию setAge. При этом функция setAge устанавливает значение для переменной age, если оно соответствует определенным условиям.

Таким образом, состояние класса скрыто извне, к нему можно получить доступ только посредством дополнительно определенных функций, который представляют интерфейс класса.

Также стоит отметить, что если в классе отсутствует спецификатор доступа или для некоторых членов класса он не определен, то по умолчанию используется спецификатор доступа private:

```c++
class Person
{
    std::string name;
    int age;
 
public:
    Person(string n, int a)
    {
        name = n; age = a;
    }
    void move()
    {
        cout << name << " is moving" << endl;
    }
    void setAge(int a) 
    {
        if (a > 0 && a < 100)
	        age = a;
    }
    std::string getName()
    {
        return name;
    }
    int getAge()
    {
        return age;
    }
};
```

Для переменных name и age здесь не определен спецификатор доступа, поэтому для них по умолчанию используется спецификатор private.

### Статические члены класса

Кроме переменных и методов, которые относятся непосредственно к объекту, C++ позволяет определять переменные и методы, которые относятся непосредственно к классу или иначе говоря статические члены класса. Статические переменные и методы относят в целом ко всему классу. Для их определения используется ключевое слово  static.

Например, в банке может быть множество различных вкладов, однако все вклады будут иметь какие-то общие процентные ставки. Так, для описания банковского счета определим и используем следующий класс:

```c++
class Account 
{
public:
    Account(double sum)
    {
        this->sum = sum;
    }
    static int getRate()
    {
        return rate;
    }
    static void setRate(int r)
    {
        rate = r;
    }
    double getIncome()
    {
        return sum + sum * rate / 100;
    }
private:
    double sum;
    static int rate;
};

int Account::rate = 8;

int main()
{
    Account account1(20000);
    Account account2(50000);
    Account::setRate(5);        // переустанавливаем значение rate
    std::cout << "Rate: " << Account::getRate() << std::endl;
    std::cout << "Rate: " << account1.getRate() << " Income: " << account1.getIncome() << std::endl;
    std::cout << "Rate: " << account2.getRate() << " Income: " << account2.getIncome() << std::endl;
    return 0;
}
```

В классе Account определена одна статическая переменная rate и две статических функции для управления этой переменной. При определении статических функций стоит учитывать, что внутри них мы можем использовать только статические переменные класса, как например, переменную rate. Нестатические переменные использовать в статических функциях нельзя.

Важно, что если класс содержит статические переменные, то они должны быть дополнительно определены вне класса:
```c++
int Account::rate = 8;
```

Присваивать начальное значение переменной необязательно.

Также стоит отметить, что так как статические члены относятся в целом ко всему классу, то для обращения к статическим членам используется имя класса, после которого идет оператор  ::. Либо мы можем также обращаться к публичным членам класса через переменные данного класса:

```c++
Account::getRate()
account1.getRate()
```
