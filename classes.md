### Определение классов
Кроме использования встроенных типов, таких как int, double и т.д., мы можем определять свои собственные типы или классы. Класс представляет составной тип, который может использовать другие типы.

Класс предназначен для описания некоторого типа объектов. То есть по сути класс является планом объекта. А объект представляет конкретное воплощение класса, его реализацию.

Класс может определять переменные и константы для хранения состояния объекта и функции для определения поведения объекта.

Например, определим простейший класс:

__Пример__
```c++
class Person 
{

};
```

Для определения класса применяется ключевое слово  class, после которого идет собственно название класса. В данном случае класс называется Person и представляет человека. После названия класса идет блок кода, который определяет тело класса.

После определения класса мы можем создавать его переменные:

```c++
class Person
{

};

int main()
{
Person person;
return 0;
}
```

Но данный класс пока что ничего не делает, поэтому изменим его:

```c++
class Person 
{
public:
	std::string name;
	int age;

	void printInfo()
	{
		std::cout << "My name and age are: " << name << ", " << age << "\n";
	}
}
```
Теперь класс Person имеет две переменных name и age, которые предназначены для хранения имени и возраста человека соответственно, а так же функцию(метод) класса, который выводит информацию на экран.

Затем в функции main создается один объект класса Person. Через точку мы можем обратиться к его переменным и методам.
```c++
int main()
{
	Person person;
	person.name = "Tom";
	person.age = 10;

	person.printInfo();
	
	return 0;
}
```

##  Конструкторы и деструкторы

### Конструкторы

На прошлом занятии нами был написал следующий класс:
```c++
class Person
{
public:
    std::string name;
    int age;
};
```
И мы можем установить значения для переменных класса Person, можем получить их значения во внешние переменные. Однако если мы попробуем получить значения переменных name и age до их установки, то результаты будут неопределенными:

```c++
Person person;
std::cout << "Name: " << person.name << "\tAge: " << person.age << endl;
```

Чтобы избежать подобной ситуации применяются специальные функции инициализации или конструкторы. Они позволяют инициализировать объект класса. Так, изменим код программы следующим образом:

```c++
#include <iostream>
#include <string>
 
class Person
{
public:
    std::string name;
    int age;
    
    Person(std::string _name, int _age) 
    {
        name = _name;
        age = _age;
    }
};
```

Теперь в классе Person определен конструктор:

```c++
Person(std::string _name, int _age) 
{
    name = _name;
    age = _age;
}
```
Следовательно мы можем написать:

```c++
Person person = Person("Tom", 22);
std::cout << "Name: " << person.name << "\tAge: " << person.age << endl;
```

По сути конструктор представляет функцию, которая может принимать параметры и которая должна называться по имени класса. В данном случае конструктор принимает два параметра и передает их значения полям name и age.

После этого вызова у объекта person для поля name будет определено значение "Tom", а для поля age - значение 22. Впоследствии мы также сможем обращаться к этим полям и переустанавливать их значения.

Тажке можно использовать сокращенную форму инициализации:

```c++
Person person("Tom", 22);
```

По сути она будет эквивалентна предыдущей.

Подобным образом мы можем определить несколько конструкторов и затем их использовать:

```c++
#include <iostream>
#include <string>

class Person
{
public:
    std::string name;
    int age;
    
    Person() {
        name = "Tom";
        age = 18;
    }

    Person(std::string _name, int _age) 
    {
        name = _name; 
        age = _age;
    }
};
```

Так же существует другая сокращенная форма инициализации переменных:

```c++
Person(std::string _name, int _age): name(_name), age(_age) {}
```

По сути для каждого указанного после двоеточия объекта вызывается его конструктор от указанных в скобках аргументов. После двоеточия в том числе можно вызывать и конструктор данного класса:

```c++
#include <iostream>
#include <string>

class Person
{
public:
    std::string name;
    int age;
    
    Person(): Person("Tom", 18) {}

    Person(std::string _name, int _age) 
    {
        name = _name; 
        age = _age;
    }
};
```

### Деструкторы

Деструктор выполняет освобождение использованных объектом ресурсов и удаление нестатических переменных объекта. По сути деструктор - это функция, которая называется по имени класса (как и конструктор) и перед которой стоит тильда (~). Деструктор не имеет возвращаемого значения и не принимает параметров. Каждый класс может иметь только один деструктор.

Деструктор автоматически вызывается, когда удаляется объект. Удаление объекта происходит в следующих случаях:

-   когда завершается выполнение области видимости, внутри которой определены объекты
-   когда удаляется контейнер (например, массив), который содержит объекты
-   когда удаляется объект, в котором определены переменные, представляющие другие объекты
- динамически созданные объекты удаляются при применении к указателю на объект оператора  delete

Рассмотрим следующую ситуацию:

```c++
#include <iostream>
#include <string>
 
class Person
{
public: 
    std::string name;
    
    Person(std::string n)
    {
        name = n;
    }
    
    ~Person()
    {
        std::cout << "Destructor called for Person " << name << std::endl;
    }
};

int main()
{
    Person tom("Tom");
    std::cout << "End of Main" << std::endl;
    return 0;
} // вызывается деструктор для объекта tom
```
В классе Person определен деструктор:
```c++
~Person()
{
    std::cout << "Destructor called for Person " << name << std::endl;
}
```

Все, что делает данный деструктор, это выводит на консоль соответствующее сообщение. Как правило, деструкторы определяют код для освобождения ресурсов, но в данном случае нам не надо освобождать никаких ресурсов, и мы могли бы определить даже пустой деструктор.

При этом выполнение самого деструктора еще не удаляет сам объект. Непосредственно удаление объекта производится в ходе явной фазы удаления, которая следует после выполнения деструктора.

Стоит также отметить, что для любого класса, который не определяет собственный деструктор, компилятор сам создает деструктор. Например, если бы класс Person не имел бы явно определенного деструктора, то для него автоматически создавался бы следующий деструктор:

```c++
~Person(){}
```

###  Управление доступом. Инкапсуляция

Выше мы описали класс Person:

```c++
class Person
{
public:
    std::string name;
    int age;
    
    Person(const std::string &n, int a) 
    {
        name = n; age = a;
    }
    
    void printInfo()
	{
		std::cout << "My name and age are: " << name << ", " << age << "\n";
	}
};
```
Спецификатор  public  является спецификатором доступа (access specifier), то есть определяет параметры доступа к членам класса - переменным и функциям. В частности, он делает их доступными из любой части программы или открытыми. По сути спецификатор public определяет общедоступный интерфейс класса.

То есть в данном случае поля name и age являются открытыми, и мы можем присвоить им во внешнем коде любые значения:

```c++
Person tom("Tom", 22);
tom.name = "abyrvalk";
tom.age = -1001;
```
 В том числе можно присвоить какие-то недопустимые значения, например, отрицательное значение для возраста пользователя. Естественно это не очень хорошая ситуация.

Однако с помощью другого спецификатора  private  мы можем скрыть реализацию членов класса, то есть сделать их закрытыми, инкапсулировать внутри класса.

Перепишем класс Person с исключением спецификатора private:

```c++
class Person
{
public:
    Person(string n, int a)
    {
        name = n; age = a;
    }
    
    void printInfo()
	{
		std::cout << "My name and age are: " << name << ", " << age << "\n";
	}
    
    void setAge(int a) 
    {
        if (a > 0 && a < 100)
	        age = a;
    }
    
    std::string getName()
    {
        return name;
    }
    
    int getAge()
    {
        return age;
    }
    
private:
    std::string name;
    int age;
     
};
 
int main()
{
    Person tom("Tom", 22);
    // string personName = tom.name;    // ошибка - переменная name закрытая
    cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << endl;
    tom.setAge(31);
    cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << endl;
    tom.setAge(291);
    cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << endl;
    return 0;
}
```

Теперь переменные name и age в классе Person являются закрытыми, поэтому мы не можем обратиться к ним напрямую. Мы можем к ним обращаться только внутри класса.

Чтобы все таки можно было получить извне значения переменных name и age, определены дополнительные функции getAge и getName. Установить значение переменной name напрямую можно только через конструктор, а значение переменной age - через конструктор или через функцию setAge. При этом функция setAge устанавливает значение для переменной age, если оно соответствует определенным условиям.

Таким образом, состояние класса скрыто извне, к нему можно получить доступ только посредством дополнительно определенных функций, который представляют интерфейс класса.

Также стоит отметить, что если в классе отсутствует спецификатор доступа или для некоторых членов класса он не определен, то по умолчанию используется спецификатор доступа private:

```c++
class Person
{
    std::string name;
    int age;
 
public:
    Person(string n, int a)
    {
        name = n; age = a;
    }
    void move()
    {
        cout << name << " is moving" << endl;
    }
    void setAge(int a) 
    {
        if (a > 0 && a < 100)
	        age = a;
    }
    std::string getName()
    {
        return name;
    }
    int getAge()
    {
        return age;
    }
};
```

Для переменных name и age здесь не определен спецификатор доступа, поэтому для них по умолчанию используется спецификатор private.

### Статические члены класса

Кроме переменных и методов, которые относятся непосредственно к объекту, C++ позволяет определять переменные и методы, которые относятся непосредственно к классу или иначе говоря статические члены класса. Статические переменные и методы относят в целом ко всему классу. Для их определения используется ключевое слово  static.

Например, в банке может быть множество различных вкладов, однако все вклады будут иметь какие-то общие процентные ставки. Так, для описания банковского счета определим и используем следующий класс:

```c++
class Account 
{
public:
    Account(double sum)
    {
        this->sum = sum;
    }
    static int getRate()
    {
        return rate;
    }
    static void setRate(int r)
    {
        rate = r;
    }
    double getIncome()
    {
        return sum + sum * rate / 100;
    }
private:
    double sum;
    static int rate;
};

int Account::rate = 8;

int main()
{
    Account account1(20000);
    Account account2(50000);
    Account::setRate(5);        // переустанавливаем значение rate
    std::cout << "Rate: " << Account::getRate() << std::endl;
    std::cout << "Rate: " << account1.getRate() << " Income: " << account1.getIncome() << std::endl;
    std::cout << "Rate: " << account2.getRate() << " Income: " << account2.getIncome() << std::endl;
    return 0;
}
```

В классе Account определена одна статическая переменная rate и две статических функции для управления этой переменной. При определении статических функций стоит учитывать, что внутри них мы можем использовать только статические переменные класса, как например, переменную rate. Нестатические переменные использовать в статических функциях нельзя.

Важно, что если класс содержит статические переменные, то они должны быть дополнительно определены вне класса:
```c++
int Account::rate = 8;
```

Присваивать начальное значение переменной необязательно.

Также стоит отметить, что так как статические члены относятся в целом ко всему классу, то для обращения к статическим членам используется имя класса, после которого идет оператор  ::. Либо мы можем также обращаться к публичным членам класса через переменные данного класса:

```c++
Account::getRate()
account1.getRate()
```
