## Перегрузка операторов

Оператор - это символ, который сообщает компилятору выполнить определенные математические или логические манипуляции. C ++ богат встроенными операторами и предоставляет следующие типы операторов:

-   Арифметические операторы (сложение, умножение и т.д.)
-   Реляционные операторы (больше, меньше, равно, ...)
-   Логические операторы (логическое и, или, ...)
-   Побитовые операторы
-   Операторы присваивания
-   Другие операторы

Перегрузка операторов позволяет определить действия, которые будет выполнять оператор. Перегрузка подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора. Функция оператора может быть определена как член класса, либо вне класса.

Перегрузить можно только те операторы, которые уже определены в C++. Создать новые операторы нельзя.

Если функция оператора определена как отдельная функция и не является членом класса, то количество параметров такой функции совпадает с количеством операндов оператора. При этом как минимум один из параметров должен представлять тип класса

Рассмотрим пример с классом Counter, который представляет секундомер и хранит количество секунд:

```c++
#include <iostream>
 
class Counter
{
public:
	int seconds;
	
    Counter(int sec) {
        seconds = sec;
    }
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
};
 
Counter operator + (Counter c1, Counter c2) {
    return Counter(c1.seconds + c2.seconds);
}
 
int main()
{
    Counter c1(20);
    Counter c2(10);
    Counter c3 = c1 + c2;
    c3.display();   // 30 seconds

    return 0;
}
```
Здесь функция оператора не является частью класса Counter и определена вне его. Данная функция перегружает оператор сложения для типа Counter. Она является бинарной, поэтому принимает два параметра. В данном случае мы складываем два объекта Counter. Возвращает функция также объект Counter, который хранит сумму секунд операндов. То есть по сути здесь операция сложения сводится к сложению секунд обоих объектов. 

При этом необязательно возвращать объект класса. Это может быть и объект встроенного примитивного типа. И также мы можем определять дополнительные перегруженные функции операторов:

```c++
int operator + (Counter c1, int s) {
    return c1.seconds + s;
}
```

Также функции операторов могут быть определены как члены классов. Если функция оператора определена как член класса, то левым операндом будет текущий объект, а правый операнд передается в подобную функцию в качестве единственного параметра:

```c++
#include <iostream>
 
class Counter
{
public:
	int seconds;
	
    Counter(int sec) {
        seconds = sec;
    }
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
    
    Counter operator + (Counter c2) {
        return Counter(seconds + c2.seconds);
    }
};
 
int main() {
    Counter c1(20);
    Counter c2(10);
    Counter c3 = c1 + c2;
    c3.display();           // 30 seconds
    int seconds = c1 + 25;  // 45
     
    return 0;
}
```

Какие операторы где переопределять? Операторы присваивания, индексирования ([]), вызова (()), доступа к члену класса по указателю (->) следует определять в виде функций-членов класса. Операторы, которые изменяют состояние объекта или непосредственно связаны с объектом (инкремент, декремент,), обычно также определяются в виде функций-членов класса. Все остальные операторы чаще определяются как отдельные функции, а не члены класса.

## Операторы преобразования типов

Операторы преобразования определяют преобразование объекта одного типа в другой. Они имеют следующий общий синтаксис:
```c
operator тип() const;
```

В данном случае  `тип`  - это тот тип, в который надо преобразовать.  Например, определим оператор преобразования из типа класса в тип int:

```c++
#include <iostream>
 
class Counter
{
private:
	int seconds;
	
public:
    Counter(int sec): seconds(sec) {}
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
    
    operator int() const {
        return seconds;
    }
};

int main()
{
    Counter counter(1230);
    counter.display();      // 1230 seconds
    
    int sec = counter;
    std::cout << sec << std::endl;
    
    return 0;
}
```

Операции преобразования также могут быть неявными(пример выше), а могут быть явными. В этом случае операторы определяются с ключевым словом  explicit. А при их применении необходимо использовать операцию приведения типов:

```c++
#include <iostream>
 
class Counter
{
private:
	int seconds;
	
public:
    Counter(int sec): seconds(sec) {}
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
    
    explicit operator int() const {
        return seconds;
    }
};

int main()
{
    Counter counter(1230);
    counter.display();      // 1230 seconds
    
    int sec = (int)counter;
    std::cout << sec << std::endl;
    
    return 0;
}
```

## Шаблоны классов

Шаблоны позволяют определить конструкции (функции, классы), которые используют определенные типы, но на момент написания кода точно не известно, что это будут за типы. Иными словами, шаблоны позволяют определить универсальные конструкции, которые не зависят от определенного типа.

Допустим, нам надо написать класс точки на плоскости.  У точки должно быть две координаты, однако в некоторых задачах у точки должны быть целочисленные координаты, а в некоторых - вещественные. На первый взгляд мы можем просто написать два класса:

```c++
#include <iostream>
#include <cmath>
 
class IntPoint {
private:
    int x, y;

public:
    IntPoint(int x, int y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};

class DoublePoint {
private:
    Double x, y;

public:
    IntPoint(double x, double y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};
 
int main()
{
    IntPoint p1(10, 20);
    DoublePoint p2(10.5, 20.5);
 
    std::cout << "p1: " << p1.abs() << '\n';
    std::cout << "p2: " << p2.abs() << '\n';
    return 0;
}
```

Хотя данный пример работает, но по сути мы получаем два идентичных класса, которые отличаются только типом id. Шаблоны класса позволяют уменьшить повторяемость кода, задав для класса универсальный тип. Изменим код, применив шаблоны:

```c++
template <typename T>
class Point {
private:
    T x, y;

public:
    Point(T x, T y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};
```

Для применения шаблонов перед классом указывается ключевое слово  template, после которого идут угловые скобки. В угловых скобках после слова  typename  идет параметр шаблона. Можно определить несколько параметров шаблона, в примере выше применяется только один параметр.

Параметр шаблона представляет произвольный идентификатор, в качестве которого, как правило, применяются заглавные буквы, например, T. Но это необязательно. То есть в данном случае параметр T будет представлять некоторый тип, который становится известным во время компиляции. Это может быть и тип int, и double, и string, и любой другой тип. И теперь координаты точки будут представлять тип, который передается через параметр T.

Используем наш класс:
```c++
#include <iostream>
#include <cmath>
 
template <typename T>
class Point {
private:
    T x, y;

public:
    Point(T x, T y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};
 
int main()
{
    Point<int> p1(10, 20);
    Point<double> p2(10.5, 20.5);
 
    std::cout << "p1: " << p1.abs() << '\n';
    std::cout << "p2: " << p2.abs() << '\n';
    return 0;
}
```

При использовании шаблона класса необходимо в угловых скобках после названия класса указать конкретный тип, который будет применяться вместо параметра T. Так, в первом случае вместо T применяется тип  `int`, поэтому в конструктор класса можно передать `int`. Во втором случае применяется тип `double`, поэтому в конструктор передается `double`.

Также можно применять сразу несколько параметров. Например, мы бы хотели написать класс, в котором ранилась бы пара чего-то:
```c++
#include <iostream>
#include <string>
 
template <typename T1, typename T2>
class pair {
public:
    T1 first;
    T2 second;

    pair(T1 f, T2 s):
        first(f), second(s) {}

    void print() {
        std::cout << first << ' ' << second << '\n';
    }
};
 
int main()
{
    pair<int, std::string> p;

    p.first = 10;
    p.second = "Hello!";
 
    p.print();
    return 0;
}
```
Перегрузка операторов
Оператор - это символ, который сообщает компилятору выполнить определенные математические или логические манипуляции. C ++ богат встроенными операторами и предоставляет следующие типы операторов:

Арифметические операторы (сложение, умножение и т.д.)
Реляционные операторы (больше, меньше, равно, …)
Логические операторы (логическое и, или, …)
Побитовые операторы
Операторы присваивания
Другие операторы
Перегрузка операторов позволяет определить действия, которые будет выполнять оператор. Перегрузка подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора. Функция оператора может быть определена как член класса, либо вне класса.

Перегрузить можно только те операторы, которые уже определены в C++. Создать новые операторы нельзя.

Если функция оператора определена как отдельная функция и не является членом класса, то количество параметров такой функции совпадает с количеством операндов оператора. При этом как минимум один из параметров должен представлять тип класса

Рассмотрим пример с классом Counter, который представляет секундомер и хранит количество секунд:

#include <iostream>
 
class Counter
{
public:
	int seconds;
	
    Counter(int sec) {
        seconds = sec;
    }
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
};
 
Counter operator + (Counter c1, Counter c2) {
    return Counter(c1.seconds + c2.seconds);
}
 
int main()
{
    Counter c1(20);
    Counter c2(10);
    Counter c3 = c1 + c2;
    c3.display();   // 30 seconds

    return 0;
}
Здесь функция оператора не является частью класса Counter и определена вне его. Данная функция перегружает оператор сложения для типа Counter. Она является бинарной, поэтому принимает два параметра. В данном случае мы складываем два объекта Counter. Возвращает функция также объект Counter, который хранит сумму секунд операндов. То есть по сути здесь операция сложения сводится к сложению секунд обоих объектов.

При этом необязательно возвращать объект класса. Это может быть и объект встроенного примитивного типа. И также мы можем определять дополнительные перегруженные функции операторов:

int operator + (Counter c1, int s) {
    return c1.seconds + s;
}
Также функции операторов могут быть определены как члены классов. Если функция оператора определена как член класса, то левым операндом будет текущий объект, а правый операнд передается в подобную функцию в качестве единственного параметра:

#include <iostream>
 
class Counter
{
public:
	int seconds;
	
    Counter(int sec) {
        seconds = sec;
    }
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
    
    Counter operator + (Counter c2) {
        return Counter(seconds + c2.seconds);
    }
};
 
int main() {
    Counter c1(20);
    Counter c2(10);
    Counter c3 = c1 + c2;
    c3.display();           // 30 seconds
    int seconds = c1 + 25;  // 45
     
    return 0;
}
Какие операторы где переопределять? Операторы присваивания, индексирования ([]), вызова (()), доступа к члену класса по указателю (->) следует определять в виде функций-членов класса. Операторы, которые изменяют состояние объекта или непосредственно связаны с объектом (инкремент, декремент,), обычно также определяются в виде функций-членов класса. Все остальные операторы чаще определяются как отдельные функции, а не члены класса.

Операторы преобразования типов
Операторы преобразования определяют преобразование объекта одного типа в другой. Они имеют следующий общий синтаксис:

operator тип() const;
В данном случае тип - это тот тип, в который надо преобразовать. Например, определим оператор преобразования из типа класса в тип int:

#include <iostream>
 
class Counter
{
private:
	int seconds;
	
public:
    Counter(int sec): seconds(sec) {}
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
    
    operator int() const {
        return seconds;
    }
};

int main()
{
    Counter counter(1230);
    counter.display();      // 1230 seconds
    
    int sec = counter;
    std::cout << sec << std::endl;
    
    return 0;
}
Операции преобразования также могут быть неявными(пример выше), а могут быть явными. В этом случае операторы определяются с ключевым словом explicit. А при их применении необходимо использовать операцию приведения типов:

#include <iostream>
 
class Counter
{
private:
	int seconds;
	
public:
    Counter(int sec): seconds(sec) {}
    
    void display() {
        std::cout << seconds << " seconds" << std::endl;
    }
    
    explicit operator int() const {
        return seconds;
    }
};

int main()
{
    Counter counter(1230);
    counter.display();      // 1230 seconds
    
    int sec = (int)counter;
    std::cout << sec << std::endl;
    
    return 0;
}
Шаблоны классов
Шаблоны позволяют определить конструкции (функции, классы), которые используют определенные типы, но на момент написания кода точно не известно, что это будут за типы. Иными словами, шаблоны позволяют определить универсальные конструкции, которые не зависят от определенного типа.

Допустим, нам надо написать класс точки на плоскости. У точки должно быть две координаты, однако в некоторых задачах у точки должны быть целочисленные координаты, а в некоторых - вещественные. На первый взгляд мы можем просто написать два класса:

#include <iostream>
#include <cmath>
 
class IntPoint {
private:
    int x, y;

public:
    IntPoint(int x, int y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};

class DoublePoint {
private:
    Double x, y;

public:
    IntPoint(double x, double y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};
 
int main()
{
    IntPoint p1(10, 20);
    DoublePoint p2(10.5, 20.5);
 
    std::cout << "p1: " << p1.abs() << '\n';
    std::cout << "p2: " << p2.abs() << '\n';
    return 0;
}
Хотя данный пример работает, но по сути мы получаем два идентичных класса, которые отличаются только типом id. Шаблоны класса позволяют уменьшить повторяемость кода, задав для класса универсальный тип. Изменим код, применив шаблоны:

template <typename T>
class Point {
private:
    T x, y;

public:
    Point(T x, T y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};
Для применения шаблонов перед классом указывается ключевое слово template, после которого идут угловые скобки. В угловых скобках после слова typename идет параметр шаблона. Можно определить несколько параметров шаблона, в примере выше применяется только один параметр.

Параметр шаблона представляет произвольный идентификатор, в качестве которого, как правило, применяются заглавные буквы, например, T. Но это необязательно. То есть в данном случае параметр T будет представлять некоторый тип, который становится известным во время компиляции. Это может быть и тип int, и double, и string, и любой другой тип. И теперь координаты точки будут представлять тип, который передается через параметр T.

Используем наш класс:

#include <iostream>
#include <cmath>
 
template <typename T>
class Point {
private:
    T x, y;

public:
    Point(T x, T y):
        x(x), y(y) {}

    double abs() {
        return std::sqrt(x * x + y * y);
    }
};
 
int main()
{
    Point<int> p1(10, 20);
    Point<double> p2(10.5, 20.5);
 
    std::cout << "p1: " << p1.abs() << '\n';
    std::cout << "p2: " << p2.abs() << '\n';
    return 0;
}
При использовании шаблона класса необходимо в угловых скобках после названия класса указать конкретный тип, который будет применяться вместо параметра T. Так, в первом случае вместо T применяется тип int, поэтому в конструктор класса можно передать int. Во втором случае применяется тип double, поэтому в конструктор передается double.

Также можно применять сразу несколько параметров. Например, мы бы хотели написать класс, в котором ранилась бы пара чего-то:

#include <iostream>
#include <string>
 
template <typename T1, typename T2>
class pair {
public:
    T1 first;
    T2 second;

    pair(T1 f, T2 s):
        first(f), second(s) {}

    void print() {
        std::cout << first << ' ' << second << '\n';
    }
};
 
int main()
{
    pair<int, std::string> p;

    p.first = 10;
    p.second = "Hello!";
 
    p.print();
    return 0;
}
Markdown 8482 bytes 1168 words 302 lines Ln 9, Col 2HTML 6538 characters 1139 words 206 paragraphs
